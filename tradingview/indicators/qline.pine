// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© YELENA AI Trading Platform

//@version=6
indicator("YELENA v2: QLine - Adaptive Trend Ribbon", overlay=true, max_labels_count=500)

// ============================================================================
// QLINE v2 â€” ADAPTIVE TREND RIBBON (SuperTrend-based)
// ============================================================================
// Dynamic trend line: green below price = support, red above price = resistance.
// Uses Pine Script BUILT-IN ta.supertrend() â€” NEVER manual implementation.
//
// CRITICAL: ta.supertrend(factor, atr_length) returns [value, direction]
//   direction = -1 means UPTREND (line below price, green)
//   direction =  1 means DOWNTREND (line above price, red)
//   The built-in handles all ratcheting correctly (line only moves in trend dir).
//
// v2 ENHANCEMENTS over v1:
//   1. Auto-optimized settings per symbol/timeframe (lookup tables)
//   2. Trend duration tracking with age classification
//   3. Touch counting with 3-bar minimum gap between touches
//   4. Bounce quality scoring (1-3 stars)
//   5. QLine slope analysis (accelerating/flat/decelerating)
//   6. Price extension warnings (> 2.5 ATR from QLine)
//   7. Info table with all real-time metrics
//   8. Enhanced webhook payload
//   9. Hidden plot exports for Master Confluence
//  10. alertcondition() entries for TradingView alerts
// ============================================================================

// ==================== AUTO-OPTIMIZATION ENGINE ====================
tf_seconds = timeframe.in_seconds(timeframe.period)
string tf_group = tf_seconds <= 60 ? "scalp" : tf_seconds <= 900 ? "intraday" : "swing"

// Settings mode
string settings_mode = input.string("Auto", "Settings Mode", options=["Auto", "Manual"], group="âš™ï¸ Settings Mode", tooltip="Auto = optimal settings per symbol/timeframe. Manual = use your custom values below.")

// Manual override inputs
int manual_atr_length = input.int(14, "ATR Length", minval=5, maxval=50, group="ðŸ”§ Manual Settings", tooltip="Period for ATR calculation")
float manual_factor = input.float(2.0, "Factor (ATR Multiplier)", minval=0.5, maxval=5.0, step=0.1, group="ðŸ”§ Manual Settings", tooltip="Distance from price â€” higher = wider, fewer flips")

// Visual settings
int line_width = input.int(2, "Line Width", minval=1, maxval=5, group="ðŸŽ¨ Visuals")
bool show_fill = input.bool(true, "Show Price Fill", group="ðŸŽ¨ Visuals", tooltip="Fill between price and QLine")
bool show_flip_labels = input.bool(true, "Show Flip Labels", group="ðŸŽ¨ Visuals")
bool show_bounce_markers = input.bool(true, "Show Bounce Markers", group="ðŸŽ¨ Visuals")
bool show_extension_warnings = input.bool(true, "Show Extension Warnings", group="ðŸŽ¨ Visuals")
string table_position = input.string("Top Right", "Info Table Position", options=["Top Right", "Top Left", "Bottom Right", "Bottom Left"], group="ðŸŽ¨ Visuals")

// Touch detection
float touch_atr_pct = input.float(0.15, "Touch Threshold (ATR %)", minval=0.05, maxval=0.50, step=0.05, group="ðŸ“ Touch Detection", tooltip="How close price must be to QLine to count as touch, as fraction of ATR")

// Alert settings
string passphrase = input.string("", "Webhook Passphrase", group="ðŸ”” Alerts", tooltip="Secret key for webhook authentication")
bool alert_on_flip = input.bool(true, "Alert on Trend Flip", group="ðŸ”” Alerts")
bool alert_on_bounce = input.bool(true, "Alert on Quality Bounce", group="ðŸ”” Alerts")

// ==================== AUTO-OPTIMIZATION LOOKUP TABLES ====================
// Generated by optimize_params.py on 2026-02-13 21:43:02
// These values are REAL optimized results from backtesting against historical data.
// DO NOT manually edit â€” re-run the optimizer to update.

f_auto_atr_length() =>
    string t = syminfo.ticker
    if t == "SPY"
        tf_group == "scalp" ? 18 : tf_group == "intraday" ? 10 : 20
    else if t == "QQQ"
        tf_group == "scalp" ? 18 : tf_group == "intraday" ? 14 : 10
    else if t == "TSLA"
        tf_group == "scalp" ? 10 : tf_group == "intraday" ? 8 : 12
    else if t == "NVDA"
        tf_group == "scalp" ? 18 : tf_group == "intraday" ? 10 : 16
    else if t == "META"
        tf_group == "scalp" ? 12 : tf_group == "intraday" ? 12 : 20
    else if t == "NFLX"
        tf_group == "scalp" ? 10 : tf_group == "intraday" ? 14 : 10
    else if t == "AAPL"
        tf_group == "scalp" ? 20 : tf_group == "intraday" ? 10 : 16
    else if t == "GOOGL"
        tf_group == "scalp" ? 12 : tf_group == "intraday" ? 10 : 14
    else if t == "MSFT"
        tf_group == "scalp" ? 18 : tf_group == "intraday" ? 14 : 8
    else if t == "AMZN"
        tf_group == "scalp" ? 12 : tf_group == "intraday" ? 8 : 8
    else if t == "AMD"
        tf_group == "scalp" ? 10 : tf_group == "intraday" ? 8 : 14
    else
        tf_group == "scalp" ? 14 : tf_group == "intraday" ? 12 : 16

f_auto_factor() =>
    string t = syminfo.ticker
    if t == "SPY"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 3.5
    else if t == "QQQ"
        tf_group == "scalp" ? 2.5 : tf_group == "intraday" ? 3.5 : 2.2
    else if t == "TSLA"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.0 : 3.5
    else if t == "NVDA"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 3.5
    else if t == "META"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 3.5
    else if t == "NFLX"
        tf_group == "scalp" ? 3.0 : tf_group == "intraday" ? 3.5 : 3.5
    else if t == "AAPL"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 2.8
    else if t == "GOOGL"
        tf_group == "scalp" ? 3.0 : tf_group == "intraday" ? 3.5 : 2.5
    else if t == "MSFT"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 3.5
    else if t == "AMZN"
        tf_group == "scalp" ? 3.0 : tf_group == "intraday" ? 3.5 : 2.2
    else if t == "AMD"
        tf_group == "scalp" ? 3.5 : tf_group == "intraday" ? 3.5 : 3.5
    else
        tf_group == "scalp" ? 3.0 : tf_group == "intraday" ? 3.5 : 3.0

// Apply settings
int atr_length = settings_mode == "Auto" ? f_auto_atr_length() : manual_atr_length
float factor = settings_mode == "Auto" ? f_auto_factor() : manual_factor

// ==================== SUPERTREND CALCULATION ====================
// CRITICAL: Using BUILT-IN ta.supertrend() â€” never manual implementation
// Returns [value, direction] where:
//   direction = -1 â†’ uptrend (line below price, green)
//   direction =  1 â†’ downtrend (line above price, red)
[st_value, st_direction] = ta.supertrend(factor, atr_length)

// Convert to our naming convention
float qline = st_value
bool is_uptrend = st_direction == -1
bool is_downtrend = st_direction == 1
string trend_state = is_uptrend ? "BULLISH" : "BEARISH"

// ATR value for various calculations
float atr_val = ta.atr(atr_length)

// ==================== TREND FLIP DETECTION ====================
bool prev_uptrend = st_direction[1] == -1
bool flipped_bullish = is_uptrend and not prev_uptrend and barstate.isconfirmed
bool flipped_bearish = is_downtrend and not is_downtrend[1] and barstate.isconfirmed

// ==================== TREND DURATION TRACKING ====================
var int trend_duration = 0
if is_uptrend != prev_uptrend
    trend_duration := 1
else
    trend_duration := trend_duration + 1

// Age classification
string trend_age = trend_duration <= 5 ? "FRESH" : trend_duration <= 20 ? "DEVELOPING" : trend_duration <= 50 ? "MATURE" : "EXTENDED"

// ==================== QLINE SLOPE ANALYSIS ====================
float slope_3bar = qline - nz(qline[3], qline)
float slope_pct = close != 0 ? (slope_3bar / close) * 100 : 0.0
string slope_state = math.abs(slope_pct) < 0.01 ? "FLAT" : slope_pct > 0 and is_uptrend ? "ACCELERATING" : slope_pct < 0 and is_downtrend ? "ACCELERATING" : "DECELERATING"

// ==================== TOUCH DETECTION ====================
// Touch = price comes within touch_threshold of QLine
float touch_threshold = atr_val * touch_atr_pct
float dist_to_qline = math.abs(close - qline)
bool is_touching = dist_to_qline <= touch_threshold

// 3-bar minimum gap between counted touches
var int bars_since_last_touch = 100
var int touch_count = 0

if is_uptrend != prev_uptrend
    touch_count := 0
    bars_since_last_touch := 100

if is_touching and bars_since_last_touch >= 3 and barstate.isconfirmed
    touch_count := touch_count + 1
    bars_since_last_touch := 0
else
    bars_since_last_touch := bars_since_last_touch + 1

// Touch strength classification
string touch_quality = touch_count <= 2 ? "STRONG" : touch_count <= 4 ? "NORMAL" : "WEAKENING"

// ==================== BOUNCE DETECTION ====================
// Bullish bounce: touching QLine in uptrend + bullish candle
bool bull_touch = is_touching and is_uptrend and barstate.isconfirmed
bool bull_candle = close > open and close > (low + (high - low) * 0.5)
bool bounce_bullish = bull_touch and bull_candle

// Bearish bounce: touching QLine in downtrend + bearish candle
bool bear_touch = is_touching and is_downtrend and barstate.isconfirmed
bool bear_candle = close < open and close < (high - (high - low) * 0.5)
bool bounce_bearish = bear_touch and bear_candle

// ==================== BOUNCE QUALITY SCORING ====================
// Score 1-3 stars based on: candle body ratio, trend freshness, touch count
// Body ratio: strong body = better bounce
float body_ratio = (high - low) != 0 ? math.abs(close - open) / (high - low) : 0
bool good_body = body_ratio > 0.5
bool fresh_trend = trend_duration <= 20
bool strong_touch = touch_count <= 3

int bounce_score = 0
if bounce_bullish or bounce_bearish
    bounce_score := (good_body ? 1 : 0) + (fresh_trend ? 1 : 0) + (strong_touch ? 1 : 0)

string bounce_stars = bounce_score == 3 ? "â˜…â˜…â˜…" : bounce_score == 2 ? "â˜…â˜…" : bounce_score >= 1 ? "â˜…" : ""

// ==================== PRICE EXTENSION WARNING ====================
float extension_threshold = atr_val * 4.0
bool is_extended = dist_to_qline > extension_threshold

// ==================== DISTANCE METRICS ====================
float distance_pct = close != 0 ? ((close - qline) / close) * 100 : 0.0

// ==================== ALERT CONDITIONS ====================
bool any_flip_alert = alert_on_flip and (flipped_bullish or flipped_bearish)
bool any_bounce_alert = alert_on_bounce and (bounce_bullish or bounce_bearish) and bounce_score >= 2
bool any_alert = any_flip_alert or any_bounce_alert

// ==================== VISUALIZATION ====================
// Line colors
color line_color = is_uptrend ? color.green : color.red
color fill_color = is_uptrend ? color.new(color.green, 90) : color.new(color.red, 90)

// Plot QLine
plot(qline, "QLine", color=line_color, linewidth=line_width, style=plot.style_line)

// Fill between price and QLine
p_price = plot(close, "Price", display=display.none)
p_qline = plot(qline, "QLine Fill", display=display.none)
fill(p_price, p_qline, color=show_fill ? fill_color : na, title="Trend Fill")

// Flip labels
if show_flip_labels and flipped_bullish
    label.new(bar_index, qline, "â–² BULL", style=label.style_label_up, color=color.green, textcolor=color.white, size=size.small)
if show_flip_labels and flipped_bearish
    label.new(bar_index, qline, "â–¼ BEAR", style=label.style_label_down, color=color.red, textcolor=color.white, size=size.small)

// Bounce markers with quality stars
if show_bounce_markers and bounce_bullish and bounce_score >= 2
    label.new(bar_index, low, bounce_stars, style=label.style_label_up, color=color.new(color.green, 30), textcolor=color.white, size=size.tiny)
if show_bounce_markers and bounce_bearish and bounce_score >= 2
    label.new(bar_index, high, bounce_stars, style=label.style_label_down, color=color.new(color.red, 30), textcolor=color.white, size=size.tiny)

// Extension warnings
if show_extension_warnings and is_extended and barstate.isconfirmed and bar_index % 5 == 0
    string ext_txt = "âš  EXT"
    if is_uptrend
        label.new(bar_index, high, ext_txt, style=label.style_label_down, color=color.new(color.yellow, 40), textcolor=color.black, size=size.tiny)
    else
        label.new(bar_index, low, ext_txt, style=label.style_label_up, color=color.new(color.yellow, 40), textcolor=color.black, size=size.tiny)

// ==================== INFO TABLE ====================
string tbl_pos = switch table_position
    "Top Right" => position.top_right
    "Top Left" => position.top_left
    "Bottom Right" => position.bottom_right
    "Bottom Left" => position.bottom_left
    => position.top_right

var table info_table = table.new(tbl_pos, 2, 9, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast
    // Row 0: Name
    table.cell(info_table, 0, 0, "QLine v2", text_color=color.white, text_size=size.small)
    table.cell(info_table, 1, 0, "", text_color=color.white, text_size=size.small)

    // Row 1: Trend
    color trend_color = is_uptrend ? color.green : color.red
    table.cell(info_table, 0, 1, "Trend", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 1, trend_state, text_color=trend_color, text_size=size.small)

    // Row 2: QLine value
    table.cell(info_table, 0, 2, "QLine", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 2, str.tostring(qline, "#.##"), text_color=color.white, text_size=size.small)

    // Row 3: Distance %
    color dist_color = distance_pct > 0 ? color.green : color.red
    table.cell(info_table, 0, 3, "Dist %", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 3, str.tostring(distance_pct, "#.##") + "%", text_color=dist_color, text_size=size.small)

    // Row 4: Trend age
    color age_color = trend_age == "FRESH" ? color.lime : trend_age == "DEVELOPING" ? color.green : trend_age == "MATURE" ? color.yellow : color.orange
    table.cell(info_table, 0, 4, "Age", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 4, trend_age + " (" + str.tostring(trend_duration) + ")", text_color=age_color, text_size=size.small)

    // Row 5: Touch count
    color touch_color = touch_quality == "STRONG" ? color.green : touch_quality == "NORMAL" ? color.yellow : color.orange
    table.cell(info_table, 0, 5, "Touches", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 5, str.tostring(touch_count) + " (" + touch_quality + ")", text_color=touch_color, text_size=size.small)

    // Row 6: Slope
    color slope_color = slope_state == "ACCELERATING" ? color.green : slope_state == "FLAT" ? color.gray : color.orange
    table.cell(info_table, 0, 6, "Slope", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 6, slope_state, text_color=slope_color, text_size=size.small)

    // Row 7: Settings
    table.cell(info_table, 0, 7, "Settings", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 7, settings_mode == "Auto" ? "Auto" : "Manual", text_color=settings_mode == "Auto" ? color.lime : color.orange, text_size=size.tiny)

    // Row 8: Params
    table.cell(info_table, 0, 8, "Params", text_color=color.gray, text_size=size.tiny)
    table.cell(info_table, 1, 8, str.tostring(atr_length) + " / " + str.tostring(factor, "#.#"), text_color=color.gray, text_size=size.tiny)

// ==================== HIDDEN PLOT EXPORTS ====================
plot(is_uptrend ? 1 : -1, "X_Trend", display=display.none)
plot(qline, "X_QLineValue", display=display.none)
plot(distance_pct, "X_DistancePct", display=display.none)
plot(trend_duration, "X_TrendDuration", display=display.none)
plot(touch_count, "X_TouchCount", display=display.none)
plot(is_extended ? 1 : 0, "X_IsExtended", display=display.none)
plot(bounce_score, "X_BounceScore", display=display.none)

// ==================== ALERTS ====================
alertcondition(flipped_bullish, "QLine: Flipped Bullish", "QLine flipped to BULLISH â€” trend reversal UP")
alertcondition(flipped_bearish, "QLine: Flipped Bearish", "QLine flipped to BEARISH â€” trend reversal DOWN")
alertcondition(bounce_bullish and bounce_score >= 2, "QLine: Quality Bullish Bounce", "QLine quality bounce off support â€” CALL setup")
alertcondition(bounce_bearish and bounce_score >= 2, "QLine: Quality Bearish Bounce", "QLine quality bounce off resistance â€” PUT setup")
alertcondition(is_extended and not is_extended[1], "QLine: Price Extended", "Price extended > 2.5 ATR from QLine â€” pullback likely")

// Dynamic webhook
if any_alert
    string alert_type = flipped_bullish ? "flip_bullish" : flipped_bearish ? "flip_bearish" : bounce_bullish ? "bounce_bullish" : "bounce_bearish"
    string alert_msg = '{"passphrase":"' + passphrase + '","ticker":"' + syminfo.ticker + '","timeframe":"' + timeframe.period + '","indicator":"qline","alert_type":"' + alert_type + '","trend":"' + trend_state + '","qline":' + str.tostring(qline, "#.##") + ',"distance_pct":' + str.tostring(distance_pct, "#.##") + ',"trend_duration":' + str.tostring(trend_duration) + ',"trend_age":"' + trend_age + '","touch_count":' + str.tostring(touch_count) + ',"touch_quality":"' + touch_quality + '","bounce_score":' + str.tostring(bounce_score) + ',"slope":"' + slope_state + '","is_extended":' + str.tostring(is_extended) + ',"price":' + str.tostring(close, "#.##") + ',"settings_mode":"' + settings_mode + '","atr_length":' + str.tostring(atr_length) + ',"factor":' + str.tostring(factor, "#.#") + ',"timestamp":"' + str.format_time(timenow, "yyyy-MM-dd'T'HH:mm:ss'Z'", "UTC") + '"}'
    alert(alert_msg, alert.freq_once_per_bar_close)
